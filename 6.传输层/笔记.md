## 传输层
* [x] 初识传输层的俩个协议
* [x] UDP(Transmission Control Protocol)
   * 数据格式
   * 校验和
   * 端口
* [x] TCP(User Datagram Protocol)
   * 数据格式以及俩个细节
   * 检验(checksum)和数据偏移(data offset)
   * 标志位(Flags)
   * 序号(Sequence Number),确认号(Acknowledge Number),窗口(Window)
   * TCP的4大要点
     * 可靠传输
     * 流量控制
     * 拥塞控制
     * 连接管理 

---
### 初识传输层的俩个协议
&emsp;传输层有2个协议:TCP(Transmission Control Protocol),传输控制协议;UDP(User Datagram Protocol),用户数据报协议.
![](./image/TCP%20and%20UDP.png)
### UDP(Transmission Control Protocol)
**1. 数据格式**
    &emsp;UDP是无连接的,减少了建立和释放连接的开销.它尽最大能力交付,不保证可靠交付.因此,首部只有8个字节(TCP首部至少20个字节),不需要维护一些复杂的参数.

![](./image/UDP.png)
* UDP长度(Length)
* 占16位,表示首部长度+数据长度
  
**2. 校验和**
* 校验和的计算内容:伪首部+首部+数据
* 伪首部:仅在计算校验和时起作用,并不会传递给网络层,17代表UDP
![](./image/UDP检验和.png)

**3. 端口**
* UDP首部中端口是占用2字节,可以推断出端口号的取值范围是:0~65535.
* 客户端的源端口是临时开启的端口
* 防火墙可以设置开启\关闭某些端口来提高安全性,比如:不允许客户端直接通过数据库端口拿到数据库文件,可以通过另一个端口执行另一个程序来服务器自己访问这个端口拿到文件给客户端
* 常用命令行
    * netstat -an:查看被占用的端口
    * netstat -anb:查看被占用的端口,占用端口的应用程序 
    * telnet 主机 端口:查看是否可以访问主机的某个端口

![](./image/port.png)
### TCP(User Datagram Protocol)
**1. 数据格式以及俩个细节**
&emsp;TCP的首部有源端口,目标端口,序号,确认号,数据偏移,保留位,标志,窗口,检验和,紧急指针,选项(长度可变),填充.

![](./image/TCP.png)
![](./image/细节.png)
&emsp;在一些资料中TCP首部的保留(Reserved)字段占3位,标志(Flags)字段占9位,比如wireshark.
* UDP的首部中有个16位的字段记录了整个UDP的长度(首部+数据)
* 但是TCP首部中仅仅4位的字段记录了TCP报文字段的首部长度,并没有字段记录TCP报文段的数据长度
* UDP首部中16位长度字段其实是多余的,纯粹是为了保证首部32bit对齐
* TCP\UDP的数据长度,完全可以由IP数据包的首部推断出来
* 传输层的数据长度 = 网络层的总长度 - 网络层的首部长度 - 传输层的首部长短
  
**2. 检验(checksum)和数据偏移(data offset)**
&emsp;跟UDP一样,TCP检验和的计算内容:伪首部+首部+数据.它的伪首部占12个字节,仅仅在计算检验和时起作用,并不会传递给网络层;数据偏移记录首部长度,它的字段乘以4就是首部长度.(建议抓包自己看)

![](./image/检验和.png)

**3. 标志位(Flags)**
 * **URG(Urgent)**:当URG为1时,紧急指针字段才有效.表表明当前报文段中有紧急数据,应优先传送.(紧急指针存储着长度,改长度代表TCP数据部位前多少字节是紧急的)
 * **ACK(Acknowledge)**:当ACK标志等于1时,确认号字段才有效.对应的时Acknowledge Number.
 * **PSH(Push)**:交互式用的
 * **RST(Reset)**:当RST=1时,表明连接出现严重差错,必须释放连接,然后再重新建立连接.
 * **SYN(Synchronization)**:当SYN=1,ACK=0时,表明这是一个建立连接的请求;若对方同意建立连接,则回复SYN=1,ACK=1.
 * **FIN(Finish)**:当FIN=1时,表明数据已经发送完毕,要求释放连接.
 

**4. 序号(Sequence Number),确认号(Acknowledge Number),窗口(Window)**
* **序号**
    * 占4个字节
    * 首先,再传输过程中每一个字节都会有一个编号
    * 在建立连接后,序号代表:这一次传给对方的TCP数据部分的第一个字节的编号
* **确认号**
    * 占4个字节
    * 在建立连接后,确认号代表:期望对方下一次传过来的TCP数据部分的第一个字节的编号
* **窗口**
    * 占2字节
    * 这个字段有流量控制功能,用以告知对方下一次允许发送的数据大小
    
**5. TCP的4大要点**
* **可靠传输**
    * **停止等待ARQ协议(Automatic Repeat-reQuest)**
      ![](./image/1.png)![](./image/2.png)
      
      这四张图分别对应了该协议的4种情况.
      &emsp;那如果有个包重传N次还是失败,会一直重传吗?这个取决于操作系统,有些系统传了5次以上就会发送reset报文(RST)断开TCP连接.
    * **连续ARQ协议+滑动窗口协议(补:SACK,选择性确认)**
     ![](./image/比较.png)
      如果接收窗口最多只能接收4个包,但发送方只发了俩个包,那么接收方等待一定事件返回确认收到2个包给发送方.
     ![](./image/TCP01_序号_确认号.png)
       * 在TCP的通信中,如果发送序列中间某个数据包丢失(比如1,2,3,4,5中的3丢失了)
       * TCP会通过重传最后确认的分组后续的分组(最后确认的是2,会重传3,4,5)
       * 这样原先已经传输的分组也可能重复发送(比如4,5),降低了TCP的性能
       * 为了改善上诉的情况,发展出来SACK技术,告诉发送方哪些数据丢失,哪些数据已经收到,TCP只重新发送丢失的包(比如3),不用发送后续所有的分组(比如4,5)
    *  **SACK(选择性确认)**
     ![](./image/SACK.png)
* **流量控制**(TCP)
 ![](./image/TCP02_流量控制.png)
   * 如果接收方的缓存区满了,发送方还疯狂发送数据,接收方只能把收到的数据包丢掉,大量的丢包会极大浪费网络资源.所有才要有流量控制.
   * 那么什么是流量控制?让发送方的发送速率不要太快,让接收方来得及处理数据.
   * 原理:
     * 通过确认报文中窗口字段来控制发送速率
     * 发送方的发送窗口大小不能超过接收方给出的窗口大小
     * 当发送方收到接窗口大小为0时,发送方就会停止发送数据
   *  有一种特殊的情况及其解决方案:
        * 一开始，接收方给发送方发送了0窗口的报文段
        * 后面，接收方又有了一些存储空间，给发送方发送的非0窗口的报文段丢失了
        * 发送方的发送窗口一直为零，双方陷入僵局(**特殊情况**)

        - 当发送方收到0窗口通知时，这时发送方停止发送报文
        - 并且同时开启一个定时器，隔一段时间就发个测试报文去询问接收方最新的窗口大小(**解决方案**)
        - 如果接收的窗口大小还是为0，则发送方再次刷新启动定时器
            
* **拥塞控制**
    * 作用:防止过多的数据注入到网络中,避免网络中的路由器或者链路过载.
    * 作用范围:拥塞控制是全局性的过程,涉及所有的主机,路由器,以及降低网络传输性能有关的所有因素.相比而言,流量控制是点对点通信的控制.
      
     ![](./image/拥塞.png)

     > MSS(Maximum Segment Size):每个段最大的数据部分大小.(在建立连接时确定,建立连接时TCP的首部的可选部分就装载着一些规则信息.在建立连接之后,取发送方和接收方的较小值作为TCP数据部分的最大值)
    * 三个重要窗口关系:
      * cwnd (congestion window):拥塞窗口,大小由发送方自己根据链路负载调整.
      * rwnd (receive window):接收窗口,大小由接收方发送的窗口大小确定.即告诉发送方,一次性最多能发多大的数据.
      * swnd (send window):发送窗口,min(cwnd,rwnd). 
      * 发送端的发送窗口是由接收窗口和拥塞窗口共同决定的
      * 其实就是 **发送窗口==接收窗口** ,然后**拥塞窗口**进行一个调整.
    * 4种拥塞控制的方法
      *  慢开始 (slow start,慢启动)
      *  拥塞避免 (congestion avoidance)
      *  快速重传 (fast retransmit)
      *  快速恢复 (fast recovery)

* **连接管理**
---
* **传输层的分段**:
&emsp;**在传输层确实可能发生“分段”，但这主要针对TCP协议，且目的是主动避免网络层的分片。UDP则不会在传输层分段。** 核心在于区分两个关键概念：
  1.  **传输层的 `分段` (Segmentation)**：  
      **仅由TCP协议执行**。TCP为了保证可靠传输并适配网络承载能力，会主动将大数据块切割成多个**段 (Segment)**。

  2.  **网络层的 `分片` (Fragmentation)**：  
      **由IP协议执行**。当传输层交给它的数据包（TCP段或UDP数据报）加上IP头后，总大小超过了网络链路的`MTU`，IP层就会被强制将其切割成多个**片 (Fragment)**。

    **应用层数据过大**
    - 应用层产生的数据（如一个大文件）可能远大于下层协议能一次性承载的大小。
     
    **传输层处理：分段 (TCP) vs 直接传递 (UDP)**
   - **TCP (传输控制协议)**：
     - **主动分段：** TCP会通过 **`路径MTU发现`** 机制，探测整条传输路径上的最小`MTU`（最大传输单元，通常1500字节）。  
     - **计算分段大小：** 确保每个 `TCP段`（TCP头 + 应用数据）在加上`IP头`（通常20字节）后，总大小 **≤ 路径MTU**（例如 ≤ 1500字节）。  
     - **目的：** 主动避免IP层分片，提升效率和可靠性（IP分片丢失一个片会导致整个包重传）。  
     - **结果：** 大块应用数据在传输层被TCP切割成多个 **TCP段**。

   - **UDP (用户数据报协议)**：
     - **无分段机制：** UDP设计简单，不会主动切割数据。  
     - **直接封装：** 无论应用层数据多大，UDP直接添加自己的头部（8字节），形成 **UDP数据报** 交给IP层。  
     - **风险：** 如果UDP数据报 + IP头 > MTU，则必然触发IP层分片。
      
    **网络层处理：分片 (IP层)**
   - 无论是TCP段还是UDP数据报，都会被封装成 **IP数据报**（添加IP头）。
   - **检查MTU：** IP层检查数据报总长度是否超出输出链路的MTU。
     - **未超出：** 直接发送。
     - **超出：** IP层执行 **分片 (Fragmentation)**：
       - 将大数据报切割成多个 **IP片 (Fragment)**。
       - 每个片都包含独立的IP头（包含分片标识、偏移量等）。
       - 分片在传输路径中可能被再次分片（若遇到更小MTU的链路）。
   - **重组：** 所有分片最终在**目标主机的IP层**被重组为原始IP数据报。

---

| **特性**         | **传输层分段 (TCP Segments)**              | **网络层分片 (IP Fragments)**               |
|------------------|------------------------------------------|------------------------------------------|
| **执行层**       | 传输层 (TCP)                             | 网络层 (IP)                              |
| **触发原因**     | 主动适配路径MTU，避免IP分片              | IP数据报超过链路MTU的被动响应            |
| **操作对象**     | 应用层数据块                             | IP数据报（可能包含TCP段或UDP数据报）     |
| **协议**         | 仅TCP                                    | IP（无论承载TCP还是UDP）                |
| **重组位置**     | 接收端传输层 (TCP)                       | 接收端网络层 (IP)                        |
| **可靠性影响**   | 丢失一个段只需重传该段 (TCP重传机制)     | 丢失一个片需重传整个原始数据报（效率低） |
| **UDP是否发生**  | ❌ 不会                                   | ✔️ 可能发生（若UDP数据报 + IP头 > MTU）  |

---

### 🌰 举个栗子
1. **发送一个2MB的文件：**
   - **TCP：**  
     → 应用层：2MB数据  
     → 传输层：TCP根据MTU（如1500字节）将其切割成约1400个 **TCP段**（每个段约1460字节数据 + 20字节TCP头）。  
     → 网络层：每个TCP段加上20字节IP头，形成1480字节的IP包（< MTU 1500），**无需IP分片**。

   - **UDP：**  
     → 应用层：2MB数据  
     → 传输层：UDP添加8字节头部，形成约2MB的 **UDP数据报**。  
     → 网络层：IP层发现数据报超大（2MB + 20字节IP头 >> MTU 1500），将其**分片成上千个IP片**发送。


- **“分段”发生在传输层**：仅由**TCP协议主动执行**，目的是优化传输、避免IP分片。UDP在IP分片时**只会在第一个分片保留UDP头部**，后续分片仅携带数据。这是IP协议为减少开销设计的机制，但也导致UDP分片脆弱性高，实际开发中应主动避免。
- **“分片”发生在网络层**：由**IP协议被动执行**，当传输层下发的包（TCP段或UDP数据报）过大时触发。

